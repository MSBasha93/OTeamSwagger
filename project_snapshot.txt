--- PROJECT STRUCTURE ---
├── backend/
│   ├── nest-cli.json
│   ├── package.json
│   ├── prisma/
│   │   ├── migrations/
│   │   │   ├── 20250531203257_init/
│   │   ├── prisma.module.ts
│   │   ├── prisma.service.ts
│   │   ├── schema.prisma
│   ├── src/
│   │   ├── app.controller.ts
│   │   ├── app.module.ts
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.module.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── dto/
│   │   │   │   ├── auth-response.dto.ts
│   │   │   │   ├── login-user.dto.ts
│   │   │   │   ├── register-user.dto.ts
│   │   │   ├── guards/
│   │   │   │   ├── jwt-auth.guard.ts
│   │   │   │   ├── local-auth.guard.ts
│   │   │   ├── strategies/
│   │   │   │   ├── jwt.strategy.ts
│   │   │   │   ├── local.strategy.ts
│   │   ├── chat/
│   │   │   ├── chat.controller.ts
│   │   │   ├── chat.module.ts
│   │   │   ├── chat.service.ts
│   │   ├── common/
│   │   │   ├── decorators/
│   │   │   │   ├── roles.decorator.ts
│   │   │   ├── guards/
│   │   │   │   ├── roles.guard.ts
│   │   ├── main.ts
│   │   ├── rca/
│   │   │   ├── rca.module.ts
│   │   ├── screenconnect/
│   │   │   ├── screenconnect.module.ts
│   │   ├── tickets/
│   │   │   ├── dto/
│   │   │   │   ├── create-ticket.dto.ts
│   │   │   │   ├── tickets.dto.ts
│   │   │   ├── tickets.controller.ts
│   │   │   ├── tickets.module.ts
│   │   │   ├── tickets.service.ts
│   │   ├── users/
│   │   │   ├── users.module.ts
│   │   │   ├── users.service.ts
│   ├── tsconfig.build.json
│   ├── tsconfig.json
├── docker-compose.yml
├── frontend/
│   ├── app/
│   │   ├── (auth)/
│   │   │   ├── login/
│   │   │   │   ├── page.tsx
│   │   ├── (dashboard)/
│   │   │   ├── admin/
│   │   │   │   ├── page.tsx
│   │   │   ├── layout.tsx
│   │   ├── chat/
│   │   │   ├── page.tsx
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   ├── tickets/
│   │   │   ├── new/
│   │   │   │   ├── page.tsx
│   ├── components/
│   │   ├── specific/
│   │   │   ├── Navbar.tsx
│   ├── contexts/
│   │   ├── AuthContext.tsx
│   ├── lib/
│   │   ├── types.ts
│   ├── next.config.js
│   ├── package.json
│   ├── postcss.config.js
│   ├── services/
│   │   ├── api.ts
│   ├── tailwind.config.js
│   ├── tsconfig.json
├── generateProjectSnapshot.js
├── README.md
├── render.yaml



--- FILE CONTENTS ---

--- FILE: backend\nest-cli.json ---
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "webpack": false,
    "tsConfigPath": "tsconfig.build.json"
  }
}
--- END FILE: backend\nest-cli.json ---

--- FILE: backend\package.json ---
{
  "name": "oteam-backend",
  "version": "0.1.0",
  "description": "OTeam Backend API",
  "author": "OTeam Developers",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prisma:generate": "npx prisma generate",
    "prisma:migrate": "npx prisma migrate dev",
    "prisma:deploy": "npx prisma migrate deploy",
    "prisma:studio": "npx prisma studio"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.2.2",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "^7.3.1",
    "@prisma/client": "^5.14.0",
    "bcrypt": "^6.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "cookie-parser": "^1.4.6",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/cookie-parser": "^1.4.7",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "prisma": "^5.14.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
--- END FILE: backend\package.json ---

--- FILE: backend\prisma\prisma.module.ts ---
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Makes PrismaService available globally
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
--- END FILE: backend\prisma\prisma.module.ts ---

--- FILE: backend\prisma\prisma.service.ts ---
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
--- END FILE: backend\prisma\prisma.service.ts ---

--- FILE: backend\prisma\schema.prisma ---
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String?
  lastName  String?
  roles     Role[]   @default([CLIENT_SUB_USER])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation for general organization membership
  organization   Organization? @relation("OrganizationMembers", fields: [organizationId], references: [id])
  organizationId String?

  // Relation if this user is a client admin for an organization
  adminForOrganization Organization? @relation("ClientAdmins", fields: [clientAdminOrganizationId], references: [id])
  clientAdminOrganizationId String?


  ticketsCreated  Ticket[] @relation("CreatedBy")
  ticketsAssigned Ticket[] @relation("AssignedToExpert")
  rcasAuthored    Rca[]

  managedExperts User[] @relation("TDMToExperts")
  manager        User?  @relation("TDMToExperts", fields: [managerId], references: [id])
  managerId      String?

  managedOpAdmins User[] @relation("SDMToOpAdmins")
  sdm             User?  @relation("SDMToOpAdmins", fields: [sdmId], references: [id])
  sdmId           String?

  sessions ScreenConnectSessionLog[]

  @@index([organizationId])
  @@index([clientAdminOrganizationId]) // Add index for the new foreign key
  @@index([managerId])
  @@index([sdmId])
}


model Organization {
  id          String   @id @default(cuid())
  name        String   @unique
  subscription SubscriptionPlan @default(BASIC)

  // Explicitly named relations
  clientAdmins User[] @relation("ClientAdmins") // Users who are client admins of this org
  members      User[] @relation("OrganizationMembers") // All users part of this org

  tickets     Ticket[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Ticket {
  id          String   @id @default(cuid())
  title       String
  description String
  status      TicketStatus @default(OPEN)
  priority    TicketPriority @default(MEDIUM)
  sla         String? // SLA identifier (e.g., "standard", "premium-4hr")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  resolvedAt  DateTime?
  escalatedAt DateTime?

  createdBy      User         @relation("CreatedBy", fields: [createdById], references: [id])
  createdById    String
  assignedExpert User?        @relation("AssignedToExpert", fields: [assignedExpertId], references: [id])
  assignedExpertId String?
  organization   Organization @relation(fields: [organizationId], references: [id])
  organizationId String

  rca          Rca? // One-to-one with RCA
  chatMessages ChatMessage[]
  escalations  Escalation[]
  sessionLogs  ScreenConnectSessionLog[]

  // For proactive maintenance
  isMaintenanceTicket Boolean @default(false)
  scheduledMaintenanceTime DateTime?


  @@index([createdById])
  @@index([assignedExpertId])
  @@index([organizationId])
}

model Rca {
  id          String   @id @default(cuid())
  ticket      Ticket   @relation(fields: [ticketId], references: [id])
  ticketId    String   @unique // Each ticket has at most one RCA
  content     String // Could be JSON or Markdown from Blad Form template
  filePath    String?  // If stored as a file
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  authoredBy  User     @relation(fields: [authoredById], references: [id])
  authoredById String

  @@index([authoredById])
}

model ChatMessage {
  id        String   @id @default(cuid())
  ticket    Ticket   @relation(fields: [ticketId], references: [id])
  ticketId  String
  senderId  String   // Can be User.id or "AI_AGENT"
  senderType SenderType // USER or AI_AGENT
  content   String
  timestamp DateTime @default(now())

  @@index([ticketId])
}

model Escalation {
  id             String   @id @default(cuid())
  ticket         Ticket   @relation(fields: [ticketId], references: [id])
  ticketId       String
  escalatedFromUserId String? // User ID of the person escalating
  escalatedToUserId String?   // User ID of the person it's escalated to (e.g., TDM, SDM)
  reason         String
  escalatedAt    DateTime @default(now())
  resolved       Boolean  @default(false)
  resolvedAt     DateTime?

  @@index([ticketId])
}

model ScreenConnectSessionLog {
  id             String   @id @default(cuid())
  ticket         Ticket   @relation(fields: [ticketId], references: [id])
  ticketId       String
  expert         User     @relation(fields: [expertId], references: [id])
  expertId       String
  sessionGuid    String   @unique // From ScreenConnect
  startTime      DateTime
  endTime        DateTime?
  durationMinutes Int?     // Calculated
  notes          String?

  @@index([ticketId])
  @@index([expertId])
}

enum Role {
  CLIENT_ADMIN      // Full access for client org, manages sub-users, payments
  CLIENT_SUB_USER   // Member of client org, can create/view tickets
  EXPERT            // Technical expert
  TDM               // Technical Delivery Manager (manages Experts)
  PLATFORM_ADMIN    // Super admin for the platform
  OPERATION_ADMIN   // Facilitates workflow, handles conflicts
  SDM               // Service Delivery Manager (manages OpAdmins, escalations)
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  ON_HOLD
  RESOLVED
  CLOSED
  ESCALATED_L2 // Example, to Expert
  ESCALATED_L3 // Example, to TDM/SDM
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum SubscriptionPlan {
  BASIC
  STANDARD
  PREMIUM
  ENTERPRISE
}

enum SenderType {
  USER
  AI_AGENT
}
--- END FILE: backend\prisma\schema.prisma ---

--- FILE: backend\src\app.controller.ts ---
import { Controller, Get } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';

@ApiTags('Health')
@Controller('health')
export class AppController {
  @Get()
  getHealth(): { status: string; timestamp: string } {
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}
--- END FILE: backend\src\app.controller.ts ---

--- FILE: backend\src\app.module.ts ---
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { TicketsModule } from './tickets/tickets.module';
import { RcaModule } from './rca/rca.module';
import { ChatModule } from './chat/chat.module';
import { ScreenconnectModule } from './screenconnect/screenconnect.module';
import { AppController } from './app.controller'; // For health check

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // Makes ConfigModule available globally
      envFilePath: `.env.${process.env.NODE_ENV || 'development'}`, // e.g., .env.development
      // Fallback to just .env if specific environment file not found
      // For Render, env vars are set directly, so .env files are less critical in prod
      ignoreEnvFile: process.env.NODE_ENV === 'production', // In prod, rely on Render's env vars
    }),
    PrismaModule,
    AuthModule,
    UsersModule,
    TicketsModule,
    RcaModule,
    ChatModule,
    ScreenconnectModule,
  ],
  controllers: [AppController], // Add AppController here
  providers: [],
})
export class AppModule {}
--- END FILE: backend\src\app.module.ts ---

--- FILE: backend\src\auth\auth.controller.ts ---
// oteam/backend/src/auth/auth.controller.ts
import { Controller, Post, Body, UseGuards, Request, Get, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService, AuthResponse } from './auth.service';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { LocalAuthGuard } from './guards/local-auth.guard'; // We will create this
import { JwtAuthGuard } from './guards/jwt-auth.guard'; // We will create this
import { ApiTags, ApiBody, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { User as UserModel } from '@prisma/client'; // For typing request.user
import { AuthResponseDto } from './dto/auth-response.dto';

// Define a type for the request object when user is authenticated
interface AuthenticatedRequest extends Request {
  user: Omit<UserModel, 'password'>; // User object from LocalStrategy or JwtStrategy
}


@ApiTags('Authentication')
@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({ status: 201, description: 'User successfully registered.', type: AuthResponseDto }) // Update type if AuthResponse changes
  @ApiResponse({ status: 400, description: 'Invalid input.'})
  @ApiResponse({ status: 409, description: 'Email already in use.'})
  @Post('register')
  async register(@Body() registerUserDto: RegisterUserDto): Promise<AuthResponse> {
    return this.authService.register(registerUserDto);
  }

  @ApiOperation({ summary: 'Log in an existing user' })
  @ApiBody({ type: LoginUserDto })
  @ApiResponse({ status: 200, description: 'User successfully logged in.', type: AuthResponseDto }) // Update type
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @UseGuards(LocalAuthGuard) // This guard uses passport-local strategy
  @Post('login')
  @HttpCode(HttpStatus.OK) // Explicitly set 200 OK for POST login
  async login(@Request() req: AuthenticatedRequest): Promise<AuthResponse> {
    // req.user is populated by LocalAuthGuard -> LocalStrategy.validate
    return this.authService.login(req.user);
  }

  @ApiOperation({ summary: 'Get current user profile' })
  @ApiBearerAuth() // Indicates that this endpoint requires a Bearer token
  @ApiResponse({ status: 200, description: 'Current user profile.', /* type: UserProfileDto - create this DTO later */ })
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @UseGuards(JwtAuthGuard) // This guard uses passport-jwt strategy
  @Get('profile')
  getProfile(@Request() req: AuthenticatedRequest): Omit<UserModel, 'password'> {
    // req.user is populated by JwtAuthGuard -> JwtStrategy.validate
    return req.user;
  }
}
--- END FILE: backend\src\auth\auth.controller.ts ---

--- FILE: backend\src\auth\auth.module.ts ---
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';

@Module({
  imports: [
    UsersModule,
    PassportModule,
    ConfigModule, // Ensure ConfigService is available
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRATION_TIME'),
        },
      }),
    }),
  ],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}
--- END FILE: backend\src\auth\auth.module.ts ---

--- FILE: backend\src\auth\auth.service.ts ---
// oteam/backend/src/auth/auth.service.ts
import { Injectable, UnauthorizedException, ConflictException, InternalServerErrorException } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { User, Role } from '@prisma/client'; // Import Role
import { Prisma } from '@prisma/client';

export interface JwtTokenPayload {
  accessToken: string;
}
export interface AuthResponse {
  accessToken: string;
  user: Omit<User, 'password'>;
}


@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, pass: string): Promise<Omit<User, 'password'> | null> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await bcrypt.compare(pass, user.password))) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: Omit<User, 'password'>): Promise<AuthResponse> {
    const payload = { email: user.email, sub: user.id, roles: user.roles };
    const accessToken = this.jwtService.sign(payload);
    return {
      accessToken,
      user,
    };
  }

  async register(registerUserDto: RegisterUserDto): Promise<AuthResponse> {
    const { email, password, firstName, lastName, roles } = registerUserDto;

    const existingUser = await this.usersService.findByEmail(email);
    if (existingUser) {
      throw new ConflictException('Email already in use');
    }

    // Ensure roles is an array of Role enum values
    const userRoles = roles && roles.length > 0 ? roles : [Role.CLIENT_SUB_USER];


    try {
      const newUser = await this.usersService.createUser({
        email,
        password, // Hashing is done in usersService.createUser
        firstName,
        lastName,
        roles: { set: userRoles }, // Prisma expects { set: [...] } for enum arrays
      });
      
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password: _, ...userWithoutPassword } = newUser;
      return this.login(userWithoutPassword);

    } catch (error) {
        // Handle potential Prisma unique constraint errors if not caught by findByEmail (race condition, unlikely)
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            if (error.code === 'P2002') { // Unique constraint failed
                throw new ConflictException('Email already exists.');
            }
        }
        console.error("Registration error:", error);
        throw new InternalServerErrorException('Could not register user.');
    }
  }

  // This method is used by JwtStrategy to re-validate token and fetch fresh user data
  async validateJwtUser(payload: { sub: string }): Promise<Omit<User, 'password'> | null> {
    const user = await this.usersService.findById(payload.sub);
    if (!user) {
      return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...result } = user;
    return result;
  }
}
--- END FILE: backend\src\auth\auth.service.ts ---

--- FILE: backend\src\auth\dto\auth-response.dto.ts ---
// backend/src/auth/dto/auth-response.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { Role } from '@prisma/client'; // Or your frontend Role enum if you create a shared one

// You might want a User DTO that omits the password for responses
// Let's create a simple one here for now.
// Ideally, this UserDto would be more comprehensive and reusable.
class UserResponseDto {
    @ApiProperty({ example: 'clqj3k2x00000v9z3h4g6e8k2', description: 'User ID' })
    id: string;

    @ApiProperty({ example: 'test@example.com', description: 'User email' })
    email: string;

    @ApiProperty({ example: 'John', description: 'User first name', required: false })
    firstName?: string;

    @ApiProperty({ example: 'Doe', description: 'User last name', required: false })
    lastName?: string;

    @ApiProperty({ enum: Role, isArray: true, example: [Role.CLIENT_SUB_USER], description: 'User roles' })
    roles: Role[];

    @ApiProperty({ example: '2023-01-01T00:00:00.000Z', description: 'Creation timestamp' })
    createdAt: Date; // Or string depending on serialization

    @ApiProperty({ example: '2023-01-01T00:00:00.000Z', description: 'Update timestamp' })
    updatedAt: Date; // Or string
    
    @ApiProperty({ example: 'org_adj3k2x00000v9z3h4g6e8k2', description: 'Organization ID', required: false, nullable: true })
    organizationId?: string | null;

    @ApiProperty({ example: null, description: 'Client Admin Organization ID', required: false, nullable: true })
    clientAdminOrganizationId?: string | null;
    
    @ApiProperty({ example: null, description: 'Manager ID', required: false, nullable: true })
    managerId?: string | null;
    
    @ApiProperty({ example: null, description: 'SDM ID', required: false, nullable: true })
    sdmId?: string | null;

    // Add other fields from your User model that you want to expose, EXCLUDING password
}


export class AuthResponseDto {
    @ApiProperty({
        example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        description: 'JWT Access Token',
    })
    accessToken: string;

    @ApiProperty({ type: () => UserResponseDto, description: 'Authenticated user details' })
    user: UserResponseDto;
}
--- END FILE: backend\src\auth\dto\auth-response.dto.ts ---

--- FILE: backend\src\auth\dto\login-user.dto.ts ---
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsString, MinLength } from 'class-validator';

export class LoginUserDto {
  @ApiProperty({ example: 'test@example.com' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: 'password123' })
  @IsString()
  @MinLength(8)
  password: string;
}
--- END FILE: backend\src\auth\dto\login-user.dto.ts ---

--- FILE: backend\src\auth\dto\register-user.dto.ts ---
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsString, MinLength, IsOptional, IsEnum } from 'class-validator';
import { Role } from '@prisma/client'; // Import Role enum

export class RegisterUserDto {
  @ApiProperty({ example: 'test@example.com', description: 'User email' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: 'password123', description: 'User password' })
  @IsString()
  @MinLength(8)
  password: string;

  @ApiProperty({ example: 'John', description: 'User first name', required: false })
  @IsOptional()
  @IsString()
  firstName?: string;

  @ApiProperty({ example: 'Doe', description: 'User last name', required: false })
  @IsOptional()
  @IsString()
  lastName?: string;
  
  // Roles might be assigned by admin later, or default during registration.
  // For self-registration, typically a default role is assigned.
  // This field might be used by an admin creating a user.
  @ApiProperty({ example: [Role.CLIENT_SUB_USER], enum: Role, isArray: true, required: false })
  @IsOptional()
  @IsEnum(Role, { each: true })
  roles?: Role[]; 
}
--- END FILE: backend\src\auth\dto\register-user.dto.ts ---

--- FILE: backend\src\auth\guards\jwt-auth.guard.ts ---
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') { // 'jwt' refers to JwtStrategy
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    // Add custom authentication logic here
    // for example, call super.logIn(request) to establish a session.
    return super.canActivate(context);
  }

  handleRequest(err, user, info) {
    // You can throw an exception based on either "info" or "err" arguments
    if (err || !user) {
      // console.error('JWT Auth Error:', err, 'Info:', info?.message);
      throw err || new UnauthorizedException(info?.message || 'Unauthorized');
    }
    return user; // This user object is what gets attached to request.user
  }
}
--- END FILE: backend\src\auth\guards\jwt-auth.guard.ts ---

--- FILE: backend\src\auth\guards\local-auth.guard.ts ---
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {} // 'local' refers to LocalStrategy
--- END FILE: backend\src\auth\guards\local-auth.guard.ts ---

--- FILE: backend\src\auth\strategies\jwt.strategy.ts ---
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
// import { UsersService } from '../../users/users.service'; // No longer directly needed
import { AuthService } from '../auth.service'; // Import AuthService
import { Role, User } from '@prisma/client';

export interface JwtPayload {
  sub: string; // User ID
  email: string;
  roles: Role[];
}

// This type will be what `request.user` becomes after successful JWT validation
export type AuthenticatedUser = Omit<User, 'password'> & { userId: string };


@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    private readonly authService: AuthService, // Inject AuthService
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: JwtPayload): Promise<AuthenticatedUser> {
    const user = await this.authService.validateJwtUser({ sub: payload.sub });
    if (!user) {
      throw new UnauthorizedException('User not found or token invalid.');
    }
    // The payload already contains email and roles. We are re-fetching user from DB
    // to ensure it's still valid and has up-to-date info.
    // We map it to ensure `request.user` has a consistent shape.
    return {
        ...user, // Spread the Omit<User, 'password'>
        userId: user.id, // Explicitly add userId, though user.id already exists
    };
  }
}
--- END FILE: backend\src\auth\strategies\jwt.strategy.ts ---

--- FILE: backend\src\auth\strategies\local.strategy.ts ---
// oteam/backend/src/auth/strategies/local.strategy.ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { User } from '@prisma/client';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' }); // Passport-local uses 'username' by default, we override to 'email'
  }

  async validate(email: string, pass: string): Promise<Omit<User, 'password'>> {
    const user = await this.authService.validateUser(email, pass);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}
--- END FILE: backend\src\auth\strategies\local.strategy.ts ---

--- FILE: backend\src\chat\chat.controller.ts ---
// oteam/backend/src/chat/chat.controller.ts
import { Controller, Post, Body, UseGuards, Request } from '@nestjs/common';
import { ChatService } from './chat.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { AuthenticatedUser } from '../auth/strategies/jwt.strategy';

interface ChatRequestBody {
  message: string;
  // conversationId?: string; // For maintaining context later
}

interface AuthenticatedChatRequest extends Request {
    user: AuthenticatedUser; // Assuming user is always authenticated for this
}


@ApiTags('Chat')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard) // All chat interactions require authentication
@Controller('chat')
export class ChatController {
  constructor(private readonly chatService: ChatService) {}

  @ApiOperation({ summary: 'Send a message to the AI agent' })
  @ApiResponse({ status: 200, description: 'AI agent response.' }) // Define a DTO for response later
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @Post('ai-interact')
  async aiInteract(
    @Body() body: ChatRequestBody,
    @Request() req: AuthenticatedChatRequest,
  ): Promise<{ reply: string, ticketId?: string, intent?: string }> {
    return this.chatService.interactWithAi(body.message, req.user.userId);
  }

  // TODO: Add endpoints for client <-> expert chat later
}
--- END FILE: backend\src\chat\chat.controller.ts ---

--- FILE: backend\src\chat\chat.module.ts ---
import { Module } from '@nestjs/common';
import { ChatService } from './chat.service';
import { ChatController } from './chat.controller';
// ConfigModule is global if needed by ChatService

@Module({
  controllers: [ChatController],
  providers: [ChatService],
  exports: [ChatService]
})
export class ChatModule {}
--- END FILE: backend\src\chat\chat.module.ts ---

--- FILE: backend\src\chat\chat.service.ts ---
// oteam/backend/src/chat/chat.service.ts
import { Injectable } from '@nestjs/common';
// import { ConfigService } from '@nestjs/config'; // If you need API keys for AI
// import axios from 'axios'; // If calling external AI service

@Injectable()
export class ChatService {
  // constructor(private configService: ConfigService) {}

  async interactWithAi(message: string, userId?: string): Promise<{ reply: string, ticketId?: string, intent?: string }> {
    console.log(`AI interaction request from user ${userId || 'anonymous'}: "${message}"`);

    // TODO: Implement actual AI logic using a RAG model or other AI service
    // This is a very basic mock based on keywords
    if (message.toLowerCase().includes('password reset')) {
      return { reply: "I can help with that. To reset your password, please go to the login page and click on 'Forgot Password'. Would you like me to create a ticket for this issue if that doesn't work?" };
    } else if (message.toLowerCase().includes('create ticket') || message.toLowerCase().includes('new issue')) {
        // In a real scenario, you'd gather more details for the ticket
        return { reply: "Okay, I can help you create a ticket. What is the title of your issue?", intent: "CREATE_TICKET_START" };
    } else if (message.toLowerCase().includes('finance app error')) {
        return { reply: "I understand you're having an issue with the finance app. Can you describe the error message or what happens?", intent: "GATHER_INFO_FINANCE_APP" };
    }


    // Default fallback response
    const responses = [
        "I'm still learning! Can you please rephrase that? Or I can create a ticket for you.",
        "Thanks for your message. A human expert will review this shortly if I can't help. What else can I do?",
        "I've noted your request: '" + message + "'. Is there anything else?"
    ];
    const randomResponse = responses[Math.floor(Math.random() * responses.length)];

    return { reply: randomResponse };
  }
}
--- END FILE: backend\src\chat\chat.service.ts ---

--- FILE: backend\src\common\decorators\roles.decorator.ts ---
import { SetMetadata } from '@nestjs/common';
import { Role } from '@prisma/client'; // Your Prisma Role enum

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
--- END FILE: backend\src\common\decorators\roles.decorator.ts ---

--- FILE: backend\src\common\guards\roles.guard.ts ---
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Role } from '@prisma/client';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { AuthenticatedUser } from '../../auth/strategies/jwt.strategy';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (!requiredRoles || requiredRoles.length === 0) {
      return true; // No roles specified, access granted
    }
    const { user } = context.switchToHttp().getRequest<{ user: AuthenticatedUser }>(); // Use the defined type
    
    if (!user || !user.roles) {
        return false; // User not found or has no roles
    }
    
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
--- END FILE: backend\src\common\guards\roles.guard.ts ---

--- FILE: backend\src\main.ts ---
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import cookieParser from 'cookie-parser';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);

  app.enableCors({
    origin: configService.get('FRONTEND_URL') || 'http://localhost:3000', // For local dev with Next.js
    credentials: true,
  });
  app.use(cookieParser());
  app.setGlobalPrefix('api');

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // Strip properties that do not have any decorators
      forbidNonWhitelisted: true, // Throw an error if non-whitelisted values are provided
      transform: true, // Automatically transform payloads to DTO instances
    }),
  );

  // Swagger OpenAPI Documentation
  const config = new DocumentBuilder()
    .setTitle('OTeam API')
    .setDescription('API documentation for the OTeam platform')
    .setVersion('1.0')
    .addBearerAuth() // For JWT
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);

  const port = configService.get<number>('PORT') || 3001;
  await app.listen(port);
  console.log(`Application is running on: ${await app.getUrl()}`);
  console.log(`Swagger docs available at ${await app.getUrl()}/api/docs`);
}
bootstrap();
--- END FILE: backend\src\main.ts ---

--- FILE: backend\src\rca\rca.module.ts ---
// backend/src/rca/rca.module.ts
import { Module } from '@nestjs/common';

@Module({
  // providers: [], // Add RcaService later
  // controllers: [], // Add RcaController later
  // exports: []
})
export class RcaModule {}
--- END FILE: backend\src\rca\rca.module.ts ---

--- FILE: backend\src\screenconnect\screenconnect.module.ts ---
// backend/src/screenconnect/screenconnect.module.ts
import { Module } from '@nestjs/common';

@Module({
  // providers: [], // Add ScreenconnectService later
  // controllers: [], // Add ScreenconnectController later
  // exports: []
})
export class ScreenconnectModule {}
--- END FILE: backend\src\screenconnect\screenconnect.module.ts ---

--- FILE: backend\src\tickets\dto\create-ticket.dto.ts ---
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty, IsOptional, IsEnum } from 'class-validator';
import { TicketPriority, TicketStatus } from '@prisma/client';

export class CreateTicketDto {
  @ApiProperty({ example: 'Cannot login to finance app', description: 'Title of the ticket' })
  @IsString()
  @IsNotEmpty()
  title: string;

  @ApiProperty({ example: 'When I try to login, I get an error message saying "Invalid Credentials", but my password is correct.', description: 'Detailed description of the issue' })
  @IsString()
  @IsNotEmpty()
  description: string;

  @ApiProperty({ enum: TicketPriority, example: TicketPriority.MEDIUM, description: 'Priority of the ticket', required: false })
  @IsOptional()
  @IsEnum(TicketPriority)
  priority?: TicketPriority;

  // Status is usually set by the system, not by user on creation.
  // @ApiProperty({ enum: TicketStatus, example: TicketStatus.OPEN, description: 'Status of the ticket', required: false })
  // @IsOptional()
  // @IsEnum(TicketStatus)
  // status?: TicketStatus;

  @ApiProperty({ example: 'org_cuid_xxxxxxxx', description: 'ID of the organization this ticket belongs to', required: false })
  @IsOptional() // If the user is part of only one org, this can be inferred
  @IsString()
  organizationId?: string; 
  
  // assignedExpertId will be set by the system or an admin, not on creation by user
}
--- END FILE: backend\src\tickets\dto\create-ticket.dto.ts ---

--- FILE: backend\src\tickets\dto\tickets.dto.ts ---
// Create a tickets.dto.ts or similar
import { TicketPriority, TicketStatus } from '@prisma/client';
import { ApiProperty } from '@nestjs/swagger';

export class TicketResponseDto {
  @ApiProperty() id: string;
  @ApiProperty() title: string;
  @ApiProperty() description: string;
  @ApiProperty({ enum: TicketStatus}) status: TicketStatus;
  @ApiProperty({ enum: TicketPriority}) priority: TicketPriority;
  // ... add all other fields you want to expose, with @ApiProperty
  @ApiProperty() createdAt: Date; // Or string if you format it
  @ApiProperty() organizationId: string;
  // etc.
}
--- END FILE: backend\src\tickets\dto\tickets.dto.ts ---

--- FILE: backend\src\tickets\tickets.controller.ts ---
// oteam/backend/src/tickets/tickets.controller.ts
import { Controller, Post, Body, UseGuards, Request, Get, Param, ParseUUIDPipe, Query } from '@nestjs/common';
import { TicketsService } from './tickets.service';
import { CreateTicketDto } from './dto/create-ticket.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../common/guards/roles.guard'; // Your RolesGuard
import { Roles } from '../common/decorators/roles.decorator'; // Your Roles decorator
import { Role, Ticket } from '@prisma/client'; // Your Prisma Role enum
import { ApiTags, ApiBearerAuth, ApiOperation, ApiResponse, ApiParam, ApiQuery } from '@nestjs/swagger';
import { AuthenticatedUser } from '../auth/strategies/jwt.strategy';
import { TicketResponseDto } from './dto/tickets.dto';

interface AuthenticatedRequestWithUser extends Request {
  user: AuthenticatedUser;
}

@ApiTags('Tickets')
@ApiBearerAuth() // All endpoints in this controller require JWT
@UseGuards(JwtAuthGuard, RolesGuard) // Apply JWT and Roles guard to the whole controller
@Controller('tickets')
export class TicketsController {
  constructor(private readonly ticketsService: TicketsService) {}

  @ApiOperation({ summary: 'Create a new ticket' })
  @ApiResponse({ status: 201, description: 'Ticket successfully created.', type: TicketResponseDto }) // Assuming Ticket is your Prisma model
  @ApiResponse({ status: 400, description: 'Invalid input.'})
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @ApiResponse({ status: 403, description: 'Forbidden.'})
  @Roles(Role.CLIENT_ADMIN, Role.CLIENT_SUB_USER, Role.PLATFORM_ADMIN, Role.OPERATION_ADMIN) // Only these roles can create tickets
  @Post()
  async create(
    @Body() createTicketDto: CreateTicketDto,
    @Request() req: AuthenticatedRequestWithUser,
  ): Promise<Ticket> {
    return this.ticketsService.createTicket(createTicketDto, req.user);
  }

  @ApiOperation({ summary: 'Get all tickets (role-dependent)' })
  @ApiResponse({ status: 200, description: 'List of tickets.', type: [TicketResponseDto] })
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @ApiResponse({ status: 403, description: 'Forbidden.'})
  // All authenticated users can attempt to get tickets, service layer handles filtering by role
  @Roles(Role.CLIENT_ADMIN, Role.CLIENT_SUB_USER, Role.EXPERT, Role.TDM, Role.PLATFORM_ADMIN, Role.OPERATION_ADMIN, Role.SDM)
  @Get()
  async findAll(
    @Request() req: AuthenticatedRequestWithUser,
    // @Query() queryParams: any, // For future pagination and filtering
    ): Promise<Ticket[]> {
    return this.ticketsService.findAllTickets(req.user /*, queryParams */);
  }

  @ApiOperation({ summary: 'Get a specific ticket by ID' })
  @ApiParam({ name: 'id', type: 'string', format: 'uuid', description: 'Ticket ID' })
  @ApiResponse({ status: 200, description: 'Ticket details.', type: TicketResponseDto })
  @ApiResponse({ status: 401, description: 'Unauthorized.'})
  @ApiResponse({ status: 403, description: 'Forbidden.'})
  @ApiResponse({ status: 404, description: 'Ticket not found.'})
  // All authenticated users can attempt to get a ticket, service layer handles authorization
  @Roles(Role.CLIENT_ADMIN, Role.CLIENT_SUB_USER, Role.EXPERT, Role.TDM, Role.PLATFORM_ADMIN, Role.OPERATION_ADMIN, Role.SDM)
  @Get(':id')
  async findOne(
    @Param('id', ParseUUIDPipe) id: string,
    @Request() req: AuthenticatedRequestWithUser,
  ): Promise<Ticket | null> {
    return this.ticketsService.findTicketById(id, req.user);
  }
}
--- END FILE: backend\src\tickets\tickets.controller.ts ---

--- FILE: backend\src\tickets\tickets.module.ts ---
import { Module } from '@nestjs/common';
import { TicketsService } from './tickets.service';
import { TicketsController } from './tickets.controller';
// PrismaModule is global, so no need to import typically unless you want to be explicit

@Module({
  controllers: [TicketsController],
  providers: [TicketsService],
  exports: [TicketsService]
})
export class TicketsModule {}
--- END FILE: backend\src\tickets\tickets.module.ts ---

--- FILE: backend\src\tickets\tickets.service.ts ---
// oteam/backend/src/tickets/tickets.service.ts
import { Injectable, NotFoundException, ForbiddenException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateTicketDto } from './dto/create-ticket.dto';
import { User, Ticket, TicketStatus, Role, Organization } from '@prisma/client'; // Make sure Role is imported
import { AuthenticatedUser } from '../auth/strategies/jwt.strategy'; // For user type
import { Prisma } from '@prisma/client';

@Injectable()
export class TicketsService {
  constructor(private prisma: PrismaService) { }

  async createTicket(createTicketDto: CreateTicketDto, user: AuthenticatedUser): Promise<Ticket> {
    const { title, description, priority, organizationId: dtoOrganizationId } = createTicketDto;

    let effectiveOrganizationId = dtoOrganizationId;

    // If user is CLIENT_SUB_USER or CLIENT_ADMIN, ensure they belong to an organization.
    // For this MVP, we assume a client user is already associated with an organization.
    // This association would happen during user creation or org setup by an admin.
    const dbUser = await this.prisma.user.findUnique({
      where: { id: user.userId },
      include: { organization: true }
    });

    if (!dbUser) {
      throw new NotFoundException('User not found');
    }

    if ((user.roles.includes(Role.CLIENT_ADMIN) || user.roles.includes(Role.CLIENT_SUB_USER))) {
      if (!dbUser.organizationId) {
        throw new BadRequestException('Client users must belong to an organization to create tickets.');
      }
      // If an org ID was provided in DTO, verify it matches user's org (or if admin, allow)
      if (dtoOrganizationId && dtoOrganizationId !== dbUser.organizationId) {
        // PLATFORM_ADMIN or other high-level admins might be able to create tickets for any org
        if (!user.roles.includes(Role.PLATFORM_ADMIN) && !user.roles.includes(Role.OPERATION_ADMIN)) {
          throw new ForbiddenException('You can only create tickets for your own organization.');
        }
      }
      effectiveOrganizationId = dbUser.organizationId; // Enforce user's organization
    } else if (!effectiveOrganizationId && (user.roles.includes(Role.PLATFORM_ADMIN) || user.roles.includes(Role.OPERATION_ADMIN))) {
      // Admins must specify an org ID if they are creating a ticket on behalf of a client
      throw new BadRequestException('Admins must specify an organization ID when creating a ticket.');
    } else if (!effectiveOrganizationId) {
      // Non-client users (like Experts, TDMs if they could create tickets) would need org context
      throw new BadRequestException('Organization ID is required for this user type to create a ticket.');
    }


    // Verify the organization exists if specified or inferred
    const organization = await this.prisma.organization.findUnique({ where: { id: effectiveOrganizationId } });
    if (!organization) {
      throw new NotFoundException(`Organization with ID ${effectiveOrganizationId} not found.`);
    }


    return this.prisma.ticket.create({
      data: {
        title,
        description,
        priority: priority || undefined, // Prisma handles undefined for optional enums
        status: TicketStatus.OPEN, // Default status
        createdById: user.userId,
        organizationId: effectiveOrganizationId, // Assign to the user's organization
      },
    });
  }

  async findTicketById(id: string, user: AuthenticatedUser): Promise<Ticket | null> {
    const ticket = await this.prisma.ticket.findUnique({
      where: { id },
      include: {
        createdBy: { select: { id: true, email: true, firstName: true, lastName: true } },
        assignedExpert: { select: { id: true, email: true, firstName: true, lastName: true } },
        organization: true,
        // rca: true, // Include other relations as needed
        // chatMessages: true,
      }
    });

    if (!ticket) {
      throw new NotFoundException(`Ticket with ID ${id} not found`);
    }

    const requester = await this.prisma.user.findUnique({ where: { id: user.userId } });

    if (!requester) {
      throw new ForbiddenException('User performing the request not found.');
    }
    // Authorization: Check if user is allowed to see this ticket
    // PLATFORM_ADMIN, OPERATION_ADMIN, SDM can see all tickets
    if (user.roles.includes(Role.PLATFORM_ADMIN) || user.roles.includes(Role.OPERATION_ADMIN) || user.roles.includes(Role.SDM)) {
      return ticket;
    }
    // EXPERT or TDM can see if assigned or related (e.g., TDM manages the assigned expert)
    if ((user.roles.includes(Role.EXPERT) || user.roles.includes(Role.TDM)) && ticket.assignedExpertId === user.userId) {
      // TODO: Add logic for TDM to see tickets of their managed experts
      return ticket;
    }
    // CLIENT_ADMIN or CLIENT_SUB_USER can see if it belongs to their organization
    if ((user.roles.includes(Role.CLIENT_ADMIN) || user.roles.includes(Role.CLIENT_SUB_USER)) && ticket.organizationId === requester.organizationId) {
      const requester = await this.prisma.user.findUnique({ where: { id: user.userId } }); // fetch user to get orgId
      if (requester.organizationId && ticket.organizationId === requester.organizationId) return ticket;
    }


    throw new ForbiddenException('You do not have permission to view this ticket.');
  }

  // Placeholder for find all tickets with filtering and pagination
  async findAllTickets(user: AuthenticatedUser, /* query params for filtering/pagination */): Promise<Ticket[]> {
    const dbUser = await this.prisma.user.findUnique({ where: { id: user.userId } });
    if (!dbUser) throw new ForbiddenException('User not found');

    const whereClause: Prisma.TicketWhereInput = {};

    if (user.roles.includes(Role.CLIENT_ADMIN) || user.roles.includes(Role.CLIENT_SUB_USER)) {
      if (!dbUser.organizationId) throw new ForbiddenException("Client user not associated with an organization.");
      whereClause.organizationId = dbUser.organizationId;
    } else if (user.roles.includes(Role.EXPERT)) {
      whereClause.assignedExpertId = user.userId;
    } else if (user.roles.includes(Role.TDM)) {
      // TODO: TDM should see tickets of their experts.
      // This requires knowing which experts a TDM manages.
      // For now, TDM can only see tickets directly assigned to them (if any).
      whereClause.assignedExpertId = user.userId; // Simplified
    } else if (!user.roles.includes(Role.PLATFORM_ADMIN) && !user.roles.includes(Role.OPERATION_ADMIN) && !user.roles.includes(Role.SDM)) {
      // If not any of the above and not a super admin, they can't see a general list.
      throw new ForbiddenException("You do not have permission to view all tickets.");
    }
    // PLATFORM_ADMIN, OPERATION_ADMIN, SDM can see all if no specific filters applied by them.

    return this.prisma.ticket.findMany({
      where: whereClause,
      include: {
        createdBy: { select: { id: true, email: true, firstName: true, lastName: true } },
        assignedExpert: { select: { id: true, email: true, firstName: true, lastName: true } },
        organization: { select: { id: true, name: true } }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });
  }
}
--- END FILE: backend\src\tickets\tickets.service.ts ---

--- FILE: backend\src\users\users.module.ts ---
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
// PrismaModule is global
// If you add a UsersController later:
// import { UsersController } from './users.controller';

@Module({
  // controllers: [UsersController], // Add if you create UsersController
  providers: [UsersService],
  exports: [UsersService], // Export service for AuthModule
})
export class UsersModule {}
--- END FILE: backend\src\users\users.module.ts ---

--- FILE: backend\src\users\users.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Prisma, User, Role } from '@prisma/client';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async findByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({ where: { email } });
  }

  async findById(id: string): Promise<User | null> {
    const user = await this.prisma.user.findUnique({ where: { id } });
    if (!user) {
      // It's often better not to throw NotFoundException here if this service
      // is used internally by auth, as auth might want to handle null differently.
      // However, for a generic findById, it's appropriate.
      // For now, let's keep it simple and auth service can handle nulls.
      return null;
    }
    return user;
  }

 async createUser(data: Prisma.UserCreateInput): Promise<User> {
    const hashedPassword = await bcrypt.hash(data.password as string, 10); // Ensure password is a string

    // data.roles is expected to be Prisma.UserCreaterolesInput, e.g. { set: [Role.CLIENT_SUB_USER] }
    // If data.roles or data.roles.set is not provided, default it.
    let rolesForDb: Prisma.UserCreaterolesInput;
    if (data.roles && (data.roles as Prisma.UserCreaterolesInput).set && ((data.roles as Prisma.UserCreaterolesInput).set as Role[]).length > 0) {
        rolesForDb = data.roles as Prisma.UserCreaterolesInput;
    } else {
        rolesForDb = { set: [Role.CLIENT_SUB_USER] };
    }

    return this.prisma.user.create({
      data: {
        ...data, // Spread other fields like email, firstName, lastName
        password: hashedPassword,
        roles: rolesForDb,
      },
    });
}

  // Basic placeholder for future admin user management
  async findAll(): Promise<Omit<User, 'password'>[]> {
    const users = await this.prisma.user.findMany({
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        roles: true,
        createdAt: true,
        updatedAt: true,
        organizationId: true,
        clientAdminOrganizationId: true, // Added
        managerId: true,                 // Added
        sdmId: true,                     // Added
        // Do NOT select password
      }
    });
    // The type assertion 'as Omit<User, 'password'>[]' might be needed if TS still complains,
    // but ideally the select should match the Omit type.
    return users as Omit<User, 'password'>[];
  }

  async updateUser(id: string, data: Prisma.UserUpdateInput): Promise<User | null> {
    if (data.password && typeof data.password === 'string') {
        data.password = await bcrypt.hash(data.password, 10);
    }
    try {
        return await this.prisma.user.update({
            where: { id },
            data,
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new NotFoundException(`User with ID ${id} not found`);
        }
        throw error;
    }
  }

  async deleteUser(id: string): Promise<User | null> {
    try {
        return await this.prisma.user.delete({ where: { id } });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new NotFoundException(`User with ID ${id} not found`);
        }
        throw error;
    }
  }
}
--- END FILE: backend\src\users\users.service.ts ---

--- FILE: backend\tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
--- END FILE: backend\tsconfig.build.json ---

--- FILE: backend\tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "esModuleInterop": true, /* Enables emit interoperability between CommonJS and ES Modules */
    "resolveJsonModule": true /* Allows importing JSON files */
  }
}
--- END FILE: backend\tsconfig.json ---

--- FILE: docker-compose.yml ---
services:
  postgres_db:
    image: postgres:15
    container_name: oteam_postgres_db
    restart: always
    environment:
      POSTGRES_USER: oteam_user
      POSTGRES_PASSWORD: oteam_password
      POSTGRES_DB: oteam_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
--- END FILE: docker-compose.yml ---

--- FILE: frontend\app\(auth)\login\page.tsx ---
"use client";
import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import api from '@/services/api';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/components/ui/use-toast"; // shadcn/ui
import Link from 'next/link';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  const router = useRouter();
  const { toast } = useToast();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);
    try {
      const response = await api.post('/auth/login', { email, password });
      const { accessToken, user } = response.data;
      login(accessToken, user); // user data should include id, email, roles
      toast({ title: "Login Successful", description: `Welcome back, ${user.firstName || user.email}!` });
      // Redirect based on role, or to a default dashboard
      if (user.roles.includes('PLATFORM_ADMIN')) {
        router.push('/dashboard/admin');
      } else if (user.roles.includes('EXPERT')) {
        router.push('/dashboard/expert');
      } else {
        router.push('/dashboard/client');
      }
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Login failed. Please check your credentials.';
      setError(errorMessage);
      toast({ title: "Login Failed", description: errorMessage, variant: "destructive" });
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
      <div className="mx-auto grid w-[350px] gap-6 bg-white p-8 rounded-lg shadow-xl">
        <div className="grid gap-2 text-center">
          <h1 className="text-3xl font-bold">Login</h1>
          <p className="text-balance text-muted-foreground">
            Enter your email below to login to your account
          </p>
        </div>
        <form onSubmit={handleSubmit} className="grid gap-4">
          <div className="grid gap-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              placeholder="m@example.com"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div className="grid gap-2">
            <div className="flex items-center">
              <Label htmlFor="password">Password</Label>
              {/* <Link
                href="/forgot-password" // TODO: Implement forgot password
                className="ml-auto inline-block text-sm underline"
              >
                Forgot your password?
              </Link> */}
            </div>
            <Input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          {error && <p className="text-red-500 text-sm">{error}</p>}
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? 'Logging in...' : 'Login'}
          </Button>
        </form>
        <div className="mt-4 text-center text-sm">
          Don&apos;t have an account?{" "}
          <Link href="/register" className="underline">
            Sign up
          </Link>
        </div>
      </div>
    </div>
  );
}
--- END FILE: frontend\app\(auth)\login\page.tsx ---

--- FILE: frontend\app\(dashboard)\admin\page.tsx ---
"use client";
import { useAuth } from '@/contexts/AuthContext';
import { Role } from '@/lib/types';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export default function AdminDashboardPage() {
  const { user, hasRole } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (user && !hasRole(Role.PLATFORM_ADMIN)) {
      // Or any other admin-level roles like OPERATION_ADMIN, SDM
      router.push('/dashboard/client'); // Or a generic unauthorized page
    }
  }, [user, hasRole, router]);


  if (!user || !hasRole(Role.PLATFORM_ADMIN)) {
    return <p>Access Denied. You need admin privileges.</p>; // Or redirect
  }

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">Admin Dashboard</h1>
      <p className="mb-4">Welcome, {user.firstName || user.email}!</p>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-2">User Management</h2>
          <p>View and manage all platform users.</p>
          {/* TODO: Link to user management page */}
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-2">Ticket Overview</h2>
          <p>Monitor all tickets across the platform.</p>
          {/* TODO: Link to ticket overview page */}
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-2">System Settings</h2>
          <p>Configure platform-wide settings.</p>
          {/* TODO: Link to settings page */}
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-2">Billing & Subscriptions</h2>
          <p>Manage client subscriptions and billing.</p>
        </div>
         <div className="bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold mb-2">Expert Payroll</h2>
          <p>Monitor and manage expert payroll calculations.</p>
        </div>
      </div>
    </div>
  );
}
--- END FILE: frontend\app\(dashboard)\admin\page.tsx ---

--- FILE: frontend\app\(dashboard)\layout.tsx ---
"use client";
import { ReactNode, useEffect } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react'; // For loading spinner

interface ProtectedLayoutProps {
  children: ReactNode;
}

export default function ProtectedLayout({ children }: ProtectedLayoutProps) {
  const { user, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !user) {
      router.push('/login?redirect=' + window.location.pathname); // Redirect to login if not authenticated
    }
  }, [user, isLoading, router]);

  if (isLoading || !user) {
    return (
      <div className="flex justify-center items-center h-screen">
        <Loader2 className="h-12 w-12 animate-spin text-slate-500" />
        <p className="ml-4 text-lg">Loading dashboard...</p>
      </div>
    );
  }

  // User is authenticated, render the children (specific dashboard page)
  return <>{children}</>;
}
--- END FILE: frontend\app\(dashboard)\layout.tsx ---

--- FILE: frontend\app\chat\page.tsx ---
"use client";
import { useState, useEffect, useRef } from 'react';
import api from '@/services/api';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area"; // Assuming shadcn/ui
import { Paperclip, Send, Bot, User } from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';

interface Message {
  id: string;
  text: string;
  sender: 'user' | 'ai';
  timestamp: Date;
}

export default function AIChatPage() {
  const { user } = useAuth();
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null); // For ScrollArea's viewport

  // Mock initial greeting from AI
  useEffect(() => {
    setMessages([
      { id: 'ai-greeting', text: 'Hello! How can I help you today? I can assist with common issues or help you create a new support ticket.', sender: 'ai', timestamp: new Date() }
    ]);
  }, []);

  useEffect(() => {
    // Scroll to bottom when new messages are added
    if (scrollAreaRef.current) {
        const viewport = scrollAreaRef.current.querySelector('div[style*="overflow: scroll"]');
        if (viewport) {
            viewport.scrollTop = viewport.scrollHeight;
        }
    }
  }, [messages]);


  const handleSend = async () => {
    if (!input.trim()) return;

    const userMessage: Message = { id: Date.now().toString(), text: input, sender: 'user', timestamp: new Date() };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      // Replace with actual API call to your backend AI chat endpoint
      // The backend would then interact with the real AI service
      const response = await api.post('/chat/ai-interact', { message: input, userId: user?.id });
      const aiResponse: Message = {
        id: Date.now().toString() + '-ai',
        text: response.data.reply, // Assuming backend returns { reply: "..." }
        sender: 'ai',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, aiResponse]);
    } catch (error) {
      console.error("Error sending message to AI:", error);
      const errorResponse: Message = {
        id: Date.now().toString() + '-err',
        text: "Sorry, I couldn't connect to the AI assistant right now. Please try again later.",
        sender: 'ai',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorResponse]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-3xl mx-auto flex flex-col h-[calc(100vh-150px)] bg-white shadow-xl rounded-lg">
      <header className="bg-slate-700 text-white p-4 rounded-t-lg">
        <h1 className="text-xl font-semibold">OTeam AI Support</h1>
      </header>
      
      <ScrollArea className="flex-grow p-4" ref={scrollAreaRef}>
        <div className="space-y-4">
          {messages.map((msg) => (
            <div key={msg.id} className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
              <div className={`max-w-[70%] p-3 rounded-lg ${msg.sender === 'user' ? 'bg-blue-500 text-white' : 'bg-slate-200 text-slate-800'}`}>
                <div className="flex items-center mb-1">
                  {msg.sender === 'ai' ? <Bot size={16} className="mr-2 text-slate-600"/> : <User size={16} className="mr-2 text-blue-200"/>}
                  <span className="font-semibold text-sm">{msg.sender === 'user' ? (user?.firstName || 'You') : 'AI Assistant'}</span>
                </div>
                <p className="text-sm">{msg.text}</p>
                <p className="text-xs mt-1 opacity-70 text-right">
                  {msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </p>
              </div>
            </div>
          ))}
          {isLoading && (
            <div className="flex justify-start">
              <div className="max-w-[70%] p-3 rounded-lg bg-slate-200 text-slate-800">
                <div className="flex items-center">
                    <Bot size={16} className="mr-2 text-slate-600"/>
                    <span className="font-semibold text-sm">AI Assistant is typing...</span>
                </div>
              </div>
            </div>
          )}
        </div>
      </ScrollArea>

      <div className="border-t p-4 bg-slate-50 rounded-b-lg">
        <div className="flex items-center space-x-2">
          <Button variant="ghost" size="icon" className="text-slate-500 hover:text-slate-700">
            <Paperclip size={20} /> {/* For attachments later */}
          </Button>
          <Input
            type="text"
            placeholder="Type your message..."
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && !isLoading && handleSend()}
            className="flex-grow"
            disabled={isLoading}
          />
          <Button onClick={handleSend} disabled={isLoading || !input.trim()}>
            <Send size={18} className="mr-0 sm:mr-2"/> <span className="hidden sm:inline">Send</span>
          </Button>
        </div>
      </div>
    </div>
  );
}
--- END FILE: frontend\app\chat\page.tsx ---

--- FILE: frontend\app\globals.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Basic body styling */
body {
  @apply bg-slate-50 text-slate-900 dark:bg-slate-900 dark:text-slate-50;
  min-height: 100vh;
}
--- END FILE: frontend\app\globals.css ---

--- FILE: frontend\app\layout.tsx ---
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/contexts/AuthContext"; // We'll create this
import Navbar from "@/components/specific/Navbar"; // We'll create this
import { Toaster } from "@/components/ui/toaster"; // Assuming shadcn/ui toaster

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "OTeam Platform",
  description: "Ticketing and Support Management",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <AuthProvider>
          <Navbar />
          <main className="container mx-auto px-4 py-8">
            {children}
          </main>
          <Toaster />
        </AuthProvider>
      </body>
    </html>
  );
}
--- END FILE: frontend\app\layout.tsx ---

--- FILE: frontend\app\tickets\new\page.tsx ---
"use client";
import { useState } from 'react';
import { useRouter } from 'next/navigation';
import api from '@/services/api';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/components/ui/use-toast";
import { TicketPriority } from '@/lib/types'; // Using frontend types

export default function NewTicketPage() {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [priority, setPriority] = useState<TicketPriority>(TicketPriority.MEDIUM);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      // In a real app, organizationId might be inferred from the logged-in user's context
      const response = await api.post('/tickets', { title, description, priority });
      toast({ title: "Ticket Created", description: `Ticket "${response.data.title}" has been successfully created.` });
      router.push(`/tickets/${response.data.id}`); // Navigate to the new ticket's detail page
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || 'Failed to create ticket.';
      toast({ title: "Error", description: errorMessage, variant: "destructive" });
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto bg-white p-8 rounded-lg shadow-xl">
      <h1 className="text-3xl font-bold mb-6 text-center">Create New Ticket</h1>
      <form onSubmit={handleSubmit} className="space-y-6">
        <div>
          <Label htmlFor="title" className="block text-sm font-medium text-gray-700">Title</Label>
          <Input
            id="title"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
            className="mt-1"
          />
        </div>
        <div>
          <Label htmlFor="description" className="block text-sm font-medium text-gray-700">Description</Label>
          <Textarea
            id="description"
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            required
            rows={5}
            className="mt-1"
            placeholder="Describe your issue in detail..."
          />
        </div>
        <div>
          <Label htmlFor="priority" className="block text-sm font-medium text-gray-700">Priority</Label>
          <Select value={priority} onValueChange={(value) => setPriority(value as TicketPriority)}>
            <SelectTrigger className="w-full mt-1">
              <SelectValue placeholder="Select priority" />
            </SelectTrigger>
            <SelectContent>
              {Object.values(TicketPriority).map(p => (
                <SelectItem key={p} value={p}>{p.charAt(0) + p.slice(1).toLowerCase()}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading ? 'Submitting...' : 'Submit Ticket'}
        </Button>
      </form>
    </div>
  );
}
--- END FILE: frontend\app\tickets\new\page.tsx ---

--- FILE: frontend\components\specific\Navbar.tsx ---
"use client";
import Link from 'next/link';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button'; // Assuming shadcn/ui
import { LogOut, UserCircle, LayoutDashboard, Ticket, Bot } from 'lucide-react';

const Navbar = () => {
  const { user, logout, isLoading, hasRole } = useAuth();

  if (isLoading) {
    return (
      <nav className="bg-slate-800 text-white p-4">
        <div className="container mx-auto flex justify-between items-center">
          <Link href="/" className="text-xl font-bold">OTeam</Link>
          <div>Loading...</div>
        </div>
      </nav>
    );
  }

  return (
    <nav className="bg-slate-800 text-white p-4 shadow-md">
      <div className="container mx-auto flex justify-between items-center">
        <Link href="/" className="text-2xl font-bold hover:text-slate-300 transition-colors">
          OTeam
        </Link>
        <div className="space-x-4 flex items-center">
          {user ? (
            <>
              {hasRole("PLATFORM_ADMIN") && <Link href="/dashboard/admin" className="hover:text-slate-300">Admin Dashboard</Link>}
              {hasRole("EXPERT") && <Link href="/dashboard/expert" className="hover:text-slate-300">Expert Dashboard</Link>}
              {(hasRole("CLIENT_ADMIN") || hasRole("CLIENT_SUB_USER")) && <Link href="/dashboard/client" className="hover:text-slate-300">Client Dashboard</Link>}
              
              <Link href="/tickets/new" className="hover:text-slate-300 flex items-center">
                <Ticket size={18} className="mr-1"/> New Ticket
              </Link>
              <Link href="/chat" className="hover:text-slate-300 flex items-center">
                <Bot size={18} className="mr-1"/> AI Chat
              </Link>
              <span className="text-slate-300 hidden sm:inline">|</span>
              <span className="font-medium hidden sm:inline">{user.firstName || user.email}</span>
              <Button variant="ghost" size="sm" onClick={logout} className="hover:bg-slate-700">
                <LogOut size={18} className="mr-1 sm:mr-2"/> Logout
              </Button>
            </>
          ) : (
            <>
              <Link href="/login" className="hover:text-slate-300">Login</Link>
              <Link href="/register" className="hover:text-slate-300">Register</Link>
            </>
          )}
        </div>
      </div>
    </nav>
  );
};

export default Navbar;
--- END FILE: frontend\components\specific\Navbar.tsx ---

--- FILE: frontend\contexts\AuthContext.tsx ---
"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import api from '@/services/api'; // We'll create this
import { Role } from '@/lib/types'; // We'll create this

interface User {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  roles: Role[];
  // Add other user properties as needed
}

interface AuthContextType {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  login: (token: string, userData: User) => void;
  logout: () => void;
  hasRole: (roleOrRoles: Role | Role[]) => boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true); // Check for existing token

  useEffect(() => {
    const storedToken = localStorage.getItem('oteam_token');
    const storedUser = localStorage.getItem('oteam_user');
    if (storedToken && storedUser) {
      try {
        const parsedUser = JSON.parse(storedUser);
        setToken(storedToken);
        setUser(parsedUser);
        api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
      } catch (error) {
        console.error("Failed to parse stored user:", error);
        localStorage.removeItem('oteam_token');
        localStorage.removeItem('oteam_user');
      }
    }
    setIsLoading(false);
  }, []);

  const login = (newToken: string, userData: User) => {
    localStorage.setItem('oteam_token', newToken);
    localStorage.setItem('oteam_user', JSON.stringify(userData));
    setToken(newToken);
    setUser(userData);
    api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;
  };

  const logout = () => {
    localStorage.removeItem('oteam_token');
    localStorage.removeItem('oteam_user');
    setToken(null);
    setUser(null);
    delete api.defaults.headers.common['Authorization'];
    // Optionally redirect to login page
    window.location.href = '/login';
  };

  const hasRole = (roleOrRoles: Role | Role[]): boolean => {
    if (!user) return false;
    const rolesToCheck = Array.isArray(roleOrRoles) ? roleOrRoles : [roleOrRoles];
    return user.roles.some(userRole => rolesToCheck.includes(userRole));
  };

  return (
    <AuthContext.Provider value={{ user, token, isLoading, login, logout, hasRole }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
--- END FILE: frontend\contexts\AuthContext.tsx ---

--- FILE: frontend\lib\types.ts ---
// Mirror Prisma enums for frontend usage
export enum Role {
  CLIENT_ADMIN = "CLIENT_ADMIN",
  CLIENT_SUB_USER = "CLIENT_SUB_USER",
  EXPERT = "EXPERT",
  TDM = "TDM",
  PLATFORM_ADMIN = "PLATFORM_ADMIN",
  OPERATION_ADMIN = "OPERATION_ADMIN",
  SDM = "SDM",
}

export enum TicketStatus {
  OPEN = "OPEN",
  IN_PROGRESS = "IN_PROGRESS",
  ON_HOLD = "ON_HOLD",
  RESOLVED = "RESOLVED",
  CLOSED = "CLOSED",
  ESCALATED_L2 = "ESCALATED_L2",
  ESCALATED_L3 = "ESCALATED_L3",
}

export enum TicketPriority {
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
  URGENT = "URGENT",
}

export interface Ticket {
  id: string;
  title: string;
  description: string;
  status: TicketStatus;
  priority: TicketPriority;
  sla?: string;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
  resolvedAt?: string | null;
  createdById: string;
  assignedExpertId?: string | null;
  organizationId: string;
  // Add more fields as needed from Prisma schema
}

export interface UserProfile {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  roles: Role[];
}
--- END FILE: frontend\lib\types.ts ---

--- FILE: frontend\next.config.js ---
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // If you need to proxy API requests during development to avoid CORS issues
  // (though CORS should be handled by the backend)
  // async rewrites() {
  //   return [
  //     {
  //       source: '/api/:path*',
  //       destination: 'http://localhost:3001/api/:path*', // Proxy to Backend
  //     },
  //   ]
  // },
};

module.exports = nextConfig;
--- END FILE: frontend\next.config.js ---

--- FILE: frontend\package.json ---
{
  "name": "oteam-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.2.3",
    "axios": "^1.7.2",
    "lucide-react": "^0.379.0",
    "react-hook-form": "^7.51.5",
    "zod": "^3.23.8",
    "@hookform/resolvers": "^3.4.2", 
    "tailwind-merge": "^2.3.0",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
   "@radix-ui/react-label": "^2.0.2",          
    "@radix-ui/react-slot": "^1.0.2",          
    "@radix-ui/react-toast": "^1.1.5",         
    "@radix-ui/react-select": "^2.0.0",     
    "@radix-ui/react-scroll-area": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",  
    "@radix-ui/react-dialog": "^1.0.5",         
    "@radix-ui/react-avatar": "^1.0.4",       
    "@radix-ui/react-tooltip": "^1.0.7",       
    "@radix-ui/react-separator": "^1.0.3",    
    "@radix-ui/react-checkbox": "^1.0.4",       
    "@radix-ui/react-popover": "^1.0.7",      
    "@radix-ui/react-progress": "^1.0.3",      
    "class-variance-authority": "^0.7.0",                              
    "tailwindcss-animate": "^1.0.7"     
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^8",
    "eslint-config-next": "14.2.3"
  }
}
--- END FILE: frontend\package.json ---

--- FILE: frontend\postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
--- END FILE: frontend\postcss.config.js ---

--- FILE: frontend\services\api.ts ---
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Optional: Interceptor to handle token expiration or other global errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Handle unauthorized access, e.g., redirect to login
      // This might conflict with AuthContext's logout, so coordinate
      console.error('Unauthorized, logging out or redirecting...');
      // localStorage.removeItem('oteam_token');
      // localStorage.removeItem('oteam_user');
      // window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
--- END FILE: frontend\services\api.ts ---

--- FILE: frontend\tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [require('@tailwindcss/forms')],
};
--- END FILE: frontend\tailwind.config.js ---

--- FILE: frontend\tsconfig.json ---
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
--- END FILE: frontend\tsconfig.json ---

--- FILE: generateProjectSnapshot.js ---
// generateProjectSnapshot.js
const fs = require('fs');
const path = require('path');

const projectRoot = __dirname; // Assumes script is in project root

const excludedDirs = ['node_modules', 'dist', '.next', 'out', '.git', 'coverage'];
const excludedFiles = ['.env', '.DS_Store','pnpm-lock.yaml']; // Add specific files to exclude
const includedExtensions = ['.ts', '.tsx', '.js', '.jsx', '.json', '.prisma', '.md', '.css', '.html', '.yaml', '.yml'];

function getProjectStructure(dir, indent = '') {
    let structure = '';
    const files = fs.readdirSync(dir);

    files.forEach(file => {
        const fullPath = path.join(dir, file);
        const relPath = path.relative(projectRoot, fullPath);

        if (excludedDirs.includes(file) || excludedFiles.includes(file)) {
            return;
        }
        // Skip files starting with .env but allow .env.example
        if (file.startsWith('.env') && file !== '.env.example' && file !== '.env.local.example') {
            return;
        }


        if (fs.statSync(fullPath).isDirectory()) {
            structure += `${indent}├── ${file}/\n`;
            structure += getProjectStructure(fullPath, indent + '│   ');
        } else {
            const ext = path.extname(file);
            if (includedExtensions.includes(ext)) {
                structure += `${indent}├── ${file}\n`;
            }
        }
    });
    return structure;
}

function getFileContents(dir) {
    let contents = '';
    const files = fs.readdirSync(dir);

    files.forEach(file => {
        const fullPath = path.join(dir, file);
        const relPath = path.relative(projectRoot, fullPath);

        if (excludedDirs.includes(file) || excludedFiles.includes(file)) {
            return;
        }
        if (file.startsWith('.env') && file !== '.env.example' && file !== '.env.local.example') {
            return;
        }

        if (fs.statSync(fullPath).isDirectory()) {
            contents += getFileContents(fullPath);
        } else {
            const ext = path.extname(file);
            if (includedExtensions.includes(ext)) {
                contents += `\n--- FILE: ${relPath} ---\n`;
                try {
                    contents += fs.readFileSync(fullPath, 'utf-8');
                } catch (e) {
                    contents += `Error reading file: ${e.message}\n`;
                }
                contents += `\n--- END FILE: ${relPath} ---\n`;
            }
        }
    });
    return contents;
}

console.log("--- PROJECT STRUCTURE ---");
console.log(getProjectStructure(projectRoot));
console.log("\n\n--- FILE CONTENTS ---");
console.log(getFileContents(projectRoot));

// To save to a file:
// const output = "--- PROJECT STRUCTURE ---\n" + getProjectStructure(projectRoot) + "\n\n--- FILE CONTENTS ---\n" + getFileContents(projectRoot);
// fs.writeFileSync('project_snapshot.txt', output, 'utf-8');
// console.log("\nSnapshot written to project_snapshot.txt");
// run this script from root with node generateProjectSnapshot.js > project_snapshot.txt
--- END FILE: generateProjectSnapshot.js ---

--- FILE: README.md ---
# OTeam Platform

The Platform of OTeam is designed to simplify ticketing management for our clients in the support department.

## Project Structure

-   `backend/`: NestJS application for the API and core logic.
-   `frontend/`: Next.js application for the user interface.
-   `docker-compose.yml`: For local development environment (PostgreSQL database).
-   `render.yaml`: Blueprint for deploying to Render.com.

## Prerequisites

-   Node.js (v18+ recommended)
-   npm or yarn
-   Docker & Docker Compose (for local development)
-   Render CLI (optional, for manual Render deployments)

## Local Development Setup

1.  **Clone the repository:**
    ```bash
    git clone <your-repo-url>
    cd oteam
    ```

2.  **Backend Setup:**
    ```bash
    cd backend
    cp .env.example .env
    # Update .env with your local PostgreSQL credentials (defaults match docker-compose)
    # DATABASE_URL="postgresql://oteam_user:oteam_password@localhost:5432/oteam_db?schema=public"
    npm install
    npx prisma generate # Generate Prisma Client
    npx prisma migrate dev --name init # Apply migrations
    cd ..
    ```

3.  **Frontend Setup:**
    ```bash
    cd frontend
    cp .env.local.example .env.local
    # Update .env.local if needed (NEXT_PUBLIC_API_URL should point to your backend)
    npm install
    cd ..
    ```

4.  **Run Docker Compose (for PostgreSQL):**
    In the project root (`oteam/`):
    ```bash
    docker-compose up -d
    ```
    This will start a PostgreSQL database container.

5.  **Run Backend:**
    ```bash
    cd backend
    npm run start:dev
    # Backend will run on http://localhost:3001 (or port specified in .env)
    ```

6.  **Run Frontend:**
    In a new terminal:
    ```bash
    cd frontend
    npm run dev
    # Frontend will run on http://localhost:3000
    ```

## Tech Stack

-   **Frontend**: Next.js (React), Tailwind CSS
-   **Backend**: NestJS (Node.js, TypeScript), Prisma (ORM)
-   **Database**: PostgreSQL
-   **Authentication**: JWT
-   **Deployment**: Render.com

## User Roles (Initial)

-   `CLIENT_ADMIN`: Manages their organization's users and tickets.
-   `CLIENT_SUB_USER`: Member of a client organization, can create/view tickets.
-   `EXPERT`: Technical expert, handles assigned tickets.
-   `TDM`: Technical Delivery Manager, oversees experts.
-   `PLATFORM_ADMIN`: Super admin for the platform.
-   `OPERATION_ADMIN`: Manages platform operations.
-   `SDM`: Service Delivery Manager.

## Sprint Backlog (Initial Focus)

-   User Auth System
-   Basic DB Schema
-   AI Chat Scaffold
-   Ticket Creation Flow
-   Admin Dashboard v0
-   Expert Dashboard v0
-   API Gateway Setup
-   DevOps Init

## Deployment to Render.com

The `render.yaml` file defines the services for Render.
1.  Create a new "Blueprint" on Render.
2.  Connect your Git repository.
3.  Render will automatically detect `render.yaml` and set up the services:
    -   A PostgreSQL database.
    -   A backend web service (NestJS).
    -   A frontend static site or web service (Next.js).
4.  Environment variables need to be set in the Render dashboard for each service, especially `DATABASE_URL` for the backend and `NEXT_PUBLIC_API_URL` for the frontend.
5.  The backend's `DATABASE_URL` on Render will be provided by Render's managed PostgreSQL service.
--- END FILE: README.md ---

--- FILE: render.yaml ---
# OTeam Platform Blueprint for Render.com

# This blueprint defines:
# 1. A PostgreSQL database.
# 2. A NestJS backend service.
# 3. A Next.js frontend service.

# Make sure to set appropriate environment variables in the Render dashboard.
# For the backend, `DATABASE_URL` will be automatically injected by Render
# if you link this database service to the backend service.
# For the frontend, `NEXT_PUBLIC_API_URL` should point to your backend's public URL.

databases:
  - name: oteam-db
    databaseName: oteam_db # This will be the actual database name
    user: oteam_user      # This will be the actual database user
    plan: free            # Or your desired plan (e.g., starter)
    # PostgreSQL version can also be specified if needed, e.g., postgresqlVersion: 15

services:
  - type: web
    name: oteam-backend
    env: node
    plan: free # Or your desired plan
    rootDir: backend
    buildCommand: pnpm install && npx prisma generate && npx prisma migrate deploy && pnpm run build
    startCommand: pnpm run start:prod
    healthCheckPath: /api/health # Add a health check endpoint in your backend
    envVars:
      - key: DATABASE_URL # This will be injected from the oteam-db service
        fromDatabase:
          name: oteam-db
          property: connectionString
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 3001 # Default NestJS port, Render maps its internal port to 80/443
      - key: JWT_SECRET
        generateValue: true # Render can generate a secure secret for you
      - key: JWT_EXPIRATION_TIME
        value: 3600s # 1 hour

  - type: web # Use 'web' for Next.js with SSR, or 'static' if it's a purely static export
    name: oteam-frontend
    env: node # Next.js needs a Node environment
    plan: free # Or your desired plan
    rootDir: frontend
    buildCommand: pnpm install && pnpm run build
    startCommand: pnpm run start # Assumes `next start` in package.json scripts
    # If you use purely static export:
    # env: static
    # buildCommand: pnpm install && pnpm run build && pnpm run export # if `next export` is used
    # staticPublishPath: out # The output directory for `next export`
    envVars:
      - key: NEXT_PUBLIC_API_URL
        # Set this to your backend's public URL on Render
        # e.g., https://oteam-backend.onrender.com
        value: https://your-backend-service-name.onrender.com # IMPORTANT: Update this
      - key: NODE_ENV
        value: production
--- END FILE: render.yaml ---

